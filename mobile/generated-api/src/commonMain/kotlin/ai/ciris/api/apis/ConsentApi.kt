/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.ciris.api.apis

import ai.ciris.api.models.ConsentAuditEntry
import ai.ciris.api.models.ConsentCategoriesResponse
import ai.ciris.api.models.ConsentCleanupResponse
import ai.ciris.api.models.ConsentDecayStatus
import ai.ciris.api.models.ConsentImpactReport
import ai.ciris.api.models.ConsentQueryResponse
import ai.ciris.api.models.ConsentRequest
import ai.ciris.api.models.ConsentStatus
import ai.ciris.api.models.ConsentStatusResponse
import ai.ciris.api.models.ConsentStreamsResponse
import ai.ciris.api.models.DSARInitiateResponse
import ai.ciris.api.models.DSARStatusResponse
import ai.ciris.api.models.HTTPValidationError
import ai.ciris.api.models.PartnershipStatusResponse

import ai.ciris.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class ConsentApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Check Partnership Status
     * Check status of pending partnership request.  Returns current status and any pending partnership request outcome.
     * @param authorization  (optional)
     * @return PartnershipStatusResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun checkPartnershipStatusV1ConsentPartnershipStatusGet(authorization: kotlin.String? = null): HttpResponse<PartnershipStatusResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/partnership/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Cleanup Expired
     * Clean up expired TEMPORARY consents (admin only).  HARD DELETE after 14 days - NO GRACE PERIOD.
     * @param authorization  (optional)
     * @return ConsentCleanupResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun cleanupExpiredV1ConsentCleanupPost(authorization: kotlin.String? = null): HttpResponse<ConsentCleanupResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/consent/cleanup",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Audit Trail
     * Get consent change history - IMMUTABLE AUDIT TRAIL.
     * @param limit  (optional, default to 100)
     * @param authorization  (optional)
     * @return kotlin.collections.List<ConsentAuditEntry>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAuditTrailV1ConsentAuditGet(limit: kotlin.Int? = 100, authorization: kotlin.String? = null): HttpResponse<kotlin.collections.List<ConsentAuditEntry>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/audit",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetAuditTrailV1ConsentAuditGetResponse>().map { value }
    }

    @Serializable(GetAuditTrailV1ConsentAuditGetResponse.Companion::class)
    private class GetAuditTrailV1ConsentAuditGetResponse(val value: List<ConsentAuditEntry>) {
        companion object : KSerializer<GetAuditTrailV1ConsentAuditGetResponse> {
            private val serializer: KSerializer<List<ConsentAuditEntry>> = serializer<List<ConsentAuditEntry>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetAuditTrailV1ConsentAuditGetResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetAuditTrailV1ConsentAuditGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get Consent Categories
     * Get available consent categories for PARTNERED stream.
     * @return ConsentCategoriesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getConsentCategoriesV1ConsentCategoriesGet(): HttpResponse<ConsentCategoriesResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/categories",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Consent Status
     * Get current consent status for authenticated user.  Returns None if no consent exists (user has not interacted yet).
     * @param authorization  (optional)
     * @return ConsentStatusResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getConsentStatusV1ConsentStatusGet(authorization: kotlin.String? = null): HttpResponse<ConsentStatusResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Consent Streams
     * Get available consent streams and their descriptions.
     * @return ConsentStreamsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getConsentStreamsV1ConsentStreamsGet(): HttpResponse<ConsentStreamsResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/streams",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Dsar Status
     * Get status of a DSAR request.  Since DSAR requests are processed immediately, this always returns \&quot;completed\&quot;. In a production system with async processing, this would track actual status.
     * @param requestId
     * @param authorization  (optional)
     * @return DSARStatusResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDsarStatusV1ConsentDsarStatusRequestIdGet(requestId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<DSARStatusResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/dsar/status/{request_id}".replace("{" + "request_id" + "}", "$requestId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Impact Report
     * Get impact report showing contribution to collective learning.  Shows: - Patterns contributed - Users helped - Impact score - Example contributions (anonymized)
     * @param authorization  (optional)
     * @return ConsentImpactReport
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getImpactReportV1ConsentImpactGet(authorization: kotlin.String? = null): HttpResponse<ConsentImpactReport> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/impact",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Grant Consent
     * Grant or update consent.  Streams: - TEMPORARY: 14-day auto-forget (default) - PARTNERED: Explicit consent for mutual growth - ANONYMOUS: Statistics only, no identity
     * @param consentRequest
     * @param authorization  (optional)
     * @return ConsentStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun grantConsentV1ConsentGrantPost(consentRequest: ConsentRequest, authorization: kotlin.String? = null): HttpResponse<ConsentStatus> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = consentRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/consent/grant",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Initiate Dsar
     * Initiate automated DSAR (Data Subject Access Request).  Args:     request_type: Type of DSAR - \&quot;full\&quot;, \&quot;consent_only\&quot;, \&quot;impact_only\&quot;, or \&quot;audit_only\&quot;  Returns:     Export data matching the request type
     * @param requestType  (optional, default to "full")
     * @param authorization  (optional)
     * @return DSARInitiateResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun initiateDsarV1ConsentDsarInitiatePost(requestType: kotlin.String? = "full", authorization: kotlin.String? = null): HttpResponse<DSARInitiateResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        requestType?.apply { localVariableQuery["request_type"] = listOf("$requestType") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/consent/dsar/initiate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Query Consents
     * Query consent records with optional filters.  Args:     status: Filter by status (ACTIVE, REVOKED, EXPIRED)     user_id: Filter by user ID (admin only)  Returns:     Dictionary with consents list and total count
     * @param status  (optional)
     * @param userId  (optional)
     * @param authorization  (optional)
     * @return ConsentQueryResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun queryConsentsV1ConsentQueryGet(status: kotlin.String? = null, userId: kotlin.String? = null, authorization: kotlin.String? = null): HttpResponse<ConsentQueryResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        status?.apply { localVariableQuery["status"] = listOf("$status") }
        userId?.apply { localVariableQuery["user_id"] = listOf("$userId") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/consent/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Revoke Consent
     * Revoke consent and start decay protocol.  - Immediate identity severance - 90-day pattern decay - Safety patterns may be retained (anonymized)
     * @param reason  (optional)
     * @param authorization  (optional)
     * @return ConsentDecayStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun revokeConsentV1ConsentRevokePost(reason: kotlin.String? = null, authorization: kotlin.String? = null): HttpResponse<ConsentDecayStatus> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        reason?.apply { localVariableQuery["reason"] = listOf("$reason") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/consent/revoke",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
