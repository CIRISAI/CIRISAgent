/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.ciris.api.apis

import ai.ciris.api.models.AdapterActionRequest
import ai.ciris.api.models.ConfigurationCompleteRequest
import ai.ciris.api.models.HTTPValidationError
import ai.ciris.api.models.ResponseGetAvailableToolsV1SystemToolsGetValue
import ai.ciris.api.models.RuntimeAction
import ai.ciris.api.models.ShutdownRequest
import ai.ciris.api.models.StateTransitionRequest
import ai.ciris.api.models.StepExecutionRequest
import ai.ciris.api.models.SuccessResponseAdapterListResponse
import ai.ciris.api.models.SuccessResponseAdapterOperationResult
import ai.ciris.api.models.SuccessResponseConfigurableAdaptersResponse
import ai.ciris.api.models.SuccessResponseConfigurationCompleteResponse
import ai.ciris.api.models.SuccessResponseConfigurationSessionResponse
import ai.ciris.api.models.SuccessResponseConfigurationStatusResponse
import ai.ciris.api.models.SuccessResponseDictStrAny
import ai.ciris.api.models.SuccessResponseModuleTypesResponse
import ai.ciris.api.models.SuccessResponsePersistedConfigsResponse
import ai.ciris.api.models.SuccessResponseRemovePersistedResponse
import ai.ciris.api.models.SuccessResponseResourceUsageResponse
import ai.ciris.api.models.SuccessResponseRuntimeAdapterStatus
import ai.ciris.api.models.SuccessResponseRuntimeControlResponse
import ai.ciris.api.models.SuccessResponseServicesStatusResponse
import ai.ciris.api.models.SuccessResponseShutdownResponse
import ai.ciris.api.models.SuccessResponseStateTransitionResponse
import ai.ciris.api.models.SuccessResponseStepExecutionResponse
import ai.ciris.api.models.SuccessResponseSystemHealthResponse
import ai.ciris.api.models.SuccessResponseSystemTimeResponse

import ai.ciris.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class SystemApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Complete Configuration
     * Finalize and apply the configuration.  Validates the collected configuration and applies it to the adapter. Once completed, the adapter should be ready to use with the new configuration.  If &#x60;persist&#x60; is True, the configuration will be saved for automatic loading on startup, allowing the adapter to be automatically configured when the system restarts.  Requires ADMIN role.
     * @param sessionId
     * @param authorization  (optional)
     * @param configurationCompleteRequest  (optional)
     * @return SuccessResponseConfigurationCompleteResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun completeConfigurationV1SystemAdaptersConfigureSessionIdCompletePost(sessionId: kotlin.String, authorization: kotlin.String? = null, configurationCompleteRequest: ConfigurationCompleteRequest? = null): HttpResponse<SuccessResponseConfigurationCompleteResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = configurationCompleteRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/adapters/configure/{session_id}/complete".replace("{" + "session_id" + "}", "$sessionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Control Runtime
     * Runtime control actions.  Control agent runtime behavior. Valid actions: - pause: Pause message processing - resume: Resume message processing - state: Get current runtime state  Requires ADMIN role.
     * @param action
     * @param runtimeAction
     * @param authorization  (optional)
     * @return SuccessResponseRuntimeControlResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun controlRuntimeV1SystemRuntimeActionPost(action: kotlin.String, runtimeAction: RuntimeAction, authorization: kotlin.String? = null): HttpResponse<SuccessResponseRuntimeControlResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = runtimeAction

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/runtime/{action}".replace("{" + "action" + "}", "$action"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Execute Configuration Step
     * Execute the current configuration step.  The body contains step-specific data such as user selections, input values, or OAuth callback data. The step type determines what data is expected.  Requires ADMIN role.
     * @param sessionId
     * @param stepExecutionRequest
     * @param authorization  (optional)
     * @return SuccessResponseStepExecutionResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun executeConfigurationStepV1SystemAdaptersConfigureSessionIdStepPost(sessionId: kotlin.String, stepExecutionRequest: StepExecutionRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseStepExecutionResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = stepExecutionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/adapters/configure/{session_id}/step".replace("{" + "session_id" + "}", "$sessionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Get Adapter Status
     * Get detailed status of a specific adapter.  Returns comprehensive information about an adapter instance including configuration, metrics, and service registrations.
     * @param adapterId
     * @param authorization  (optional)
     * @return SuccessResponseRuntimeAdapterStatus
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAdapterStatusV1SystemAdaptersAdapterIdGet(adapterId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseRuntimeAdapterStatus> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/{adapter_id}".replace("{" + "adapter_id" + "}", "$adapterId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Available Tools
     * Get list of all available tools from all tool providers.  Returns tools from: - Core tool services (secrets, self_help) - Adapter tool services (API, Discord, etc.)  Requires OBSERVER role.
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, ResponseGetAvailableToolsV1SystemToolsGetValue>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getAvailableToolsV1SystemToolsGet(authorization: kotlin.String? = null): HttpResponse<kotlin.collections.Map<kotlin.String, ResponseGetAvailableToolsV1SystemToolsGetValue>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/tools",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetAvailableToolsV1SystemToolsGetResponse>().map { value }
    }

    @Serializable(GetAvailableToolsV1SystemToolsGetResponse.Companion::class)
    private class GetAvailableToolsV1SystemToolsGetResponse(val value: Map<kotlin.String, ResponseGetAvailableToolsV1SystemToolsGetValue>) {
        companion object : KSerializer<GetAvailableToolsV1SystemToolsGetResponse> {
            private val serializer: KSerializer<Map<kotlin.String, ResponseGetAvailableToolsV1SystemToolsGetValue>> = serializer<Map<String, ResponseGetAvailableToolsV1SystemToolsGetValue>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetAvailableToolsV1SystemToolsGetResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetAvailableToolsV1SystemToolsGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get Configuration Status
     * Get current status of a configuration session.  Returns complete session state including current step, collected configuration, and session status.  Requires OBSERVER role.
     * @param sessionId
     * @param authorization  (optional)
     * @return SuccessResponseConfigurationStatusResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getConfigurationStatusV1SystemAdaptersConfigureSessionIdGet(sessionId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseConfigurationStatusResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/configure/{session_id}".replace("{" + "session_id" + "}", "$sessionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Resource Usage
     * Resource usage and limits.  Returns current resource consumption, configured limits, and health status.
     * @param authorization  (optional)
     * @return SuccessResponseResourceUsageResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getResourceUsageV1SystemResourcesGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseResourceUsageResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/resources",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Services Status
     * Service status.  Returns status of all system services including health, availability, and basic metrics.
     * @param authorization  (optional)
     * @return SuccessResponseServicesStatusResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getServicesStatusV1SystemServicesGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseServicesStatusResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/services",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Session Status
     * Get the current status of a configuration session.  Useful for polling after OAuth callback to check if authentication completed.
     * @param sessionId
     * @return SuccessResponseConfigurationSessionResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSessionStatusV1SystemAdaptersConfigureSessionIdStatusGet(sessionId: kotlin.String): HttpResponse<SuccessResponseConfigurationSessionResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/configure/{session_id}/status".replace("{" + "session_id" + "}", "$sessionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get System Health
     * Overall system health.  Returns comprehensive system health including service status, initialization state, and current cognitive state.
     * @return SuccessResponseSystemHealthResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSystemHealthV1SystemHealthGet(): HttpResponse<SuccessResponseSystemHealthResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/health",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get System Time
     * System time information.  Returns both system time (host OS) and agent time (TimeService), along with synchronization status.
     * @param authorization  (optional)
     * @return SuccessResponseSystemTimeResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getSystemTimeV1SystemTimeGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseSystemTimeResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/time",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Adapters
     * List all loaded adapters.  Returns information about all currently loaded adapter instances including their type, status, and basic metrics.
     * @param authorization  (optional)
     * @return SuccessResponseAdapterListResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listAdaptersV1SystemAdaptersGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseAdapterListResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Configurable Adapters
     * List adapters that support interactive configuration.  Returns information about all adapters that have defined interactive configuration workflows, including their workflow types and step counts.  Requires ADMIN role.
     * @param authorization  (optional)
     * @return SuccessResponseConfigurableAdaptersResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listConfigurableAdaptersV1SystemAdaptersConfigurableGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseConfigurableAdaptersResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/configurable",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Module Types
     * List all available module/adapter types.  Returns both core adapters (api, cli, discord) and modular services (mcp_client, mcp_server, reddit, etc.) with their typed configuration schemas.
     * @param authorization  (optional)
     * @return SuccessResponseModuleTypesResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listModuleTypesV1SystemAdaptersTypesGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseModuleTypesResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/types",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Persisted Configurations
     * List all persisted adapter configurations.  Returns configurations that are set to load on startup.  Requires ADMIN role.
     * @param authorization  (optional)
     * @return SuccessResponsePersistedConfigsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listPersistedConfigurationsV1SystemAdaptersPersistedGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponsePersistedConfigsResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/persisted",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Load Adapter
     * Load a new adapter instance.  Dynamically loads and starts a new adapter of the specified type. Requires ADMIN role.  Adapter types: cli, api, discord, mcp, mcp_server
     * @param adapterType
     * @param adapterActionRequest
     * @param adapterId  (optional)
     * @param authorization  (optional)
     * @return SuccessResponseAdapterOperationResult
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun loadAdapterV1SystemAdaptersAdapterTypePost(adapterType: kotlin.String, adapterActionRequest: AdapterActionRequest, adapterId: kotlin.String? = null, authorization: kotlin.String? = null): HttpResponse<SuccessResponseAdapterOperationResult> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = adapterActionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        adapterId?.apply { localVariableQuery["adapter_id"] = listOf("$adapterId") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/adapters/{adapter_type}".replace("{" + "adapter_type" + "}", "$adapterType"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Local Shutdown
     * Localhost-only shutdown endpoint (no authentication required).  This endpoint is designed for Android/mobile apps where: - App data may be cleared (losing auth tokens) - Previous Python process may still be running - Need to gracefully shut down before starting new instance  Security: Only accepts requests from localhost (127.0.0.1, ::1). This is safe because only processes on the same device can call it.  Response codes for SmartStartup negotiation: - 200: Shutdown initiated successfully - 202: Shutdown already in progress - 403: Not localhost (security rejection) - 409: Resume in progress, retry later (with retry_after_ms) - 503: Server not ready
     * @return SuccessResponseShutdownResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun localShutdownV1SystemLocalShutdownPost(): HttpResponse<SuccessResponseShutdownResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/local-shutdown",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Oauth Callback
     * Handle OAuth callback from external service.  This endpoint is called by OAuth providers after user authorization. It processes the authorization code and advances the configuration workflow. Returns HTML that redirects back to the app or shows success message.  No authentication required (OAuth state validation provides security).
     * @param sessionId
     * @param code
     * @param state
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun oauthCallbackV1SystemAdaptersConfigureSessionIdOauthCallbackGet(sessionId: kotlin.String, code: kotlin.String, state: kotlin.String): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        code?.apply { localVariableQuery["code"] = listOf("$code") }
        state?.apply { localVariableQuery["state"] = listOf("$state") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/configure/{session_id}/oauth/callback".replace("{" + "session_id" + "}", "$sessionId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Oauth Deeplink Callback
     * Handle OAuth callback forwarded from Android deep link (ciris://oauth/callback).  This endpoint receives OAuth callbacks that were forwarded from OAuthCallbackActivity on Android. The Android app uses a deep link (ciris://oauth/callback) to receive the OAuth redirect from the system browser, then forwards to this endpoint.  This is a generic endpoint that works for any OAuth2 provider (Home Assistant, Discord, Google, Microsoft, Reddit, etc.) - the state parameter contains the session_id which identifies the configuration session.
     * @param code
     * @param state
     * @param provider  (optional)
     * @param source  (optional)
     * @return SuccessResponseDictStrAny
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun oauthDeeplinkCallbackV1SystemAdaptersOauthCallbackGet(code: kotlin.String, state: kotlin.String, provider: kotlin.String? = null, source: kotlin.String? = null): HttpResponse<SuccessResponseDictStrAny> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        code?.apply { localVariableQuery["code"] = listOf("$code") }
        state?.apply { localVariableQuery["state"] = listOf("$state") }
        provider?.apply { localVariableQuery["provider"] = listOf("$provider") }
        source?.apply { localVariableQuery["source"] = listOf("$source") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/system/adapters/oauth/callback",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Reload Adapter
     * Reload an adapter with new configuration.  Stops the adapter and restarts it with new configuration. Useful for applying configuration changes without full restart. Requires ADMIN role.
     * @param adapterId
     * @param adapterActionRequest
     * @param authorization  (optional)
     * @return SuccessResponseAdapterOperationResult
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun reloadAdapterV1SystemAdaptersAdapterIdReloadPut(adapterId: kotlin.String, adapterActionRequest: AdapterActionRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseAdapterOperationResult> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = adapterActionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/system/adapters/{adapter_id}/reload".replace("{" + "adapter_id" + "}", "$adapterId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Remove Persisted Configuration
     * Remove a persisted adapter configuration.  This prevents the adapter from being automatically loaded on startup.  Requires ADMIN role.
     * @param adapterType
     * @param authorization  (optional)
     * @return SuccessResponseRemovePersistedResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun removePersistedConfigurationV1SystemAdaptersAdapterTypePersistedDelete(adapterType: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseRemovePersistedResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/system/adapters/{adapter_type}/persisted".replace("{" + "adapter_type" + "}", "$adapterType"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Shutdown System
     * Graceful shutdown.  Initiates graceful system shutdown. Requires confirmation flag to prevent accidental shutdowns.  Requires ADMIN role.
     * @param shutdownRequest
     * @param authorization  (optional)
     * @return SuccessResponseShutdownResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun shutdownSystemV1SystemShutdownPost(shutdownRequest: ShutdownRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseShutdownResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = shutdownRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/shutdown",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Start Adapter Configuration
     * Start interactive configuration session for an adapter.  Creates a new configuration session and returns the session ID along with information about the first step in the workflow.  Requires ADMIN role.
     * @param adapterType
     * @param authorization  (optional)
     * @return SuccessResponseConfigurationSessionResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun startAdapterConfigurationV1SystemAdaptersAdapterTypeConfigureStartPost(adapterType: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseConfigurationSessionResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/adapters/{adapter_type}/configure/start".replace("{" + "adapter_type" + "}", "$adapterType"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Transition Cognitive State
     * Request a cognitive state transition.  Transitions the agent to a different cognitive state (WORK, DREAM, PLAY, SOLITUDE). Valid transitions depend on the current state: - From WORK: Can transition to DREAM, PLAY, or SOLITUDE - From PLAY: Can transition to WORK or SOLITUDE - From SOLITUDE: Can transition to WORK - From DREAM: Typically transitions back to WORK when complete  Requires ADMIN role.
     * @param stateTransitionRequest
     * @param authorization  (optional)
     * @return SuccessResponseStateTransitionResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun transitionCognitiveStateV1SystemStateTransitionPost(stateTransitionRequest: StateTransitionRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseStateTransitionResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = stateTransitionRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/system/state/transition",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Unload Adapter
     * Unload an adapter instance.  Stops and removes an adapter from the runtime. Will fail if it&#39;s the last communication-capable adapter. Requires ADMIN role.
     * @param adapterId
     * @param authorization  (optional)
     * @return SuccessResponseAdapterOperationResult
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun unloadAdapterV1SystemAdaptersAdapterIdDelete(adapterId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseAdapterOperationResult> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/system/adapters/{adapter_id}".replace("{" + "adapter_id" + "}", "$adapterId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
