/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.ciris.api.apis

import ai.ciris.api.models.HTTPValidationError
import ai.ciris.api.models.QueryRequest
import ai.ciris.api.models.StoreRequest
import ai.ciris.api.models.SuccessResponseGraphNode
import ai.ciris.api.models.SuccessResponseListGraphEdge
import ai.ciris.api.models.SuccessResponseListGraphNode
import ai.ciris.api.models.SuccessResponseMemoryOpResultGraphNode
import ai.ciris.api.models.SuccessResponseMemoryStats
import ai.ciris.api.models.SuccessResponseTimelineResponse

import ai.ciris.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class MemoryApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Forget Memory
     * Forget a specific memory node (FORGET).  Requires ADMIN role as this permanently removes data.
     * @param nodeId Node ID to forget
     * @param authorization  (optional)
     * @return SuccessResponseMemoryOpResultGraphNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun forgetMemoryV1MemoryNodeIdDelete(nodeId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseMemoryOpResultGraphNode> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/memory/{node_id}".replace("{" + "node_id" + "}", "$nodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Node Edges
     * Get all edges connected to a node.  Returns both incoming and outgoing edges.
     * @param nodeId Node ID
     * @param authorization  (optional)
     * @return SuccessResponseListGraphEdge
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNodeEdgesV1MemoryNodeIdEdgesGet(nodeId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseListGraphEdge> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/{node_id}/edges".replace("{" + "node_id" + "}", "$nodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Node
     * Get a specific node by ID.  Standard RESTful endpoint for node retrieval.
     * @param nodeId Node ID
     * @param authorization  (optional)
     * @return SuccessResponseGraphNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getNodeV1MemoryNodeIdGet(nodeId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseGraphNode> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/{node_id}".replace("{" + "node_id" + "}", "$nodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Stats
     * Get statistics about memory storage.  Returns counts, distributions, and metadata about the memory graph.
     * @param authorization  (optional)
     * @return SuccessResponseMemoryStats
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getStatsV1MemoryStatsGet(authorization: kotlin.String? = null): HttpResponse<SuccessResponseMemoryStats> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Timeline
     * Get a timeline view of recent memories.  Returns memories organized chronologically with time buckets.  SECURITY: OBSERVER users only see nodes they created or participated in.
     * @param hours Hours to look back (optional, default to 24)
     * @param scope Filter by scope (optional)
     * @param type Filter by node type (optional)
     * @param authorization  (optional)
     * @return SuccessResponseTimelineResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getTimelineV1MemoryTimelineGet(hours: kotlin.Int? = 24, scope: kotlin.String? = null, type: kotlin.String? = null, authorization: kotlin.String? = null): HttpResponse<SuccessResponseTimelineResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        hours?.apply { localVariableQuery["hours"] = listOf("$hours") }
        scope?.apply { localVariableQuery["scope"] = listOf("$scope") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/timeline",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Query Memory
     * Query memories with flexible filters (RECALL).  Supports querying by ID, type, text, time range, and relationships.  SECURITY: OBSERVER users only see nodes they created or participated in.
     * @param queryRequest
     * @param authorization  (optional)
     * @return SuccessResponseListGraphNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun queryMemoryV1MemoryQueryPost(queryRequest: QueryRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseListGraphNode> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = queryRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/memory/query",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Recall By Id
     * Recall a specific node by ID (legacy endpoint).  Use GET /memory/{node_id} for new implementations.  SECURITY: OBSERVER users can only access nodes they created or participated in.
     * @param nodeId Node ID to recall
     * @param authorization  (optional)
     * @return SuccessResponseGraphNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun recallByIdV1MemoryRecallNodeIdGet(nodeId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<SuccessResponseGraphNode> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/recall/{node_id}".replace("{" + "node_id" + "}", "$nodeId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Store Memory
     * Store typed nodes in memory (MEMORIZE).  This is the primary way to add information to the agent&#39;s memory. Requires ADMIN role as this modifies system state.
     * @param storeRequest
     * @param authorization  (optional)
     * @return SuccessResponseMemoryOpResultGraphNode
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun storeMemoryV1MemoryStorePost(storeRequest: StoreRequest, authorization: kotlin.String? = null): HttpResponse<SuccessResponseMemoryOpResultGraphNode> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = storeRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/memory/store",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Visualize Graph
     * Generate an interactive SVG visualization of the memory graph.  Returns an HTML page with an embedded SVG visualization.
     * @param hours Hours to look back (optional, default to 24)
     * @param layout Layout: hierarchy, timeline, circular (optional, default to "hierarchy")
     * @param width SVG width (optional, default to 800)
     * @param height SVG height (optional, default to 600)
     * @param scope Filter by scope (optional)
     * @param type Filter by node type (optional)
     * @param authorization  (optional)
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun visualizeGraphV1MemoryVisualizeGraphGet(hours: kotlin.Int? = 24, layout: kotlin.String? = "hierarchy", width: kotlin.Int? = 800, height: kotlin.Int? = 600, scope: kotlin.String? = null, type: kotlin.String? = null, authorization: kotlin.String? = null): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        hours?.apply { localVariableQuery["hours"] = listOf("$hours") }
        layout?.apply { localVariableQuery["layout"] = listOf("$layout") }
        width?.apply { localVariableQuery["width"] = listOf("$width") }
        height?.apply { localVariableQuery["height"] = listOf("$height") }
        scope?.apply { localVariableQuery["scope"] = listOf("$scope") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/memory/visualize/graph",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


}
