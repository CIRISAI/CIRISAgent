/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.ciris.api.apis

import ai.ciris.api.models.APIKeyCreateRequest
import ai.ciris.api.models.APIKeyListResponse
import ai.ciris.api.models.APIKeyResponse
import ai.ciris.api.models.ConfigureOAuthProviderRequest
import ai.ciris.api.models.ConfigureOAuthProviderResponse
import ai.ciris.api.models.HTTPValidationError
import ai.ciris.api.models.LoginRequest
import ai.ciris.api.models.LoginResponse
import ai.ciris.api.models.NativeTokenRequest
import ai.ciris.api.models.NativeTokenResponse
import ai.ciris.api.models.OAuthProvidersResponse
import ai.ciris.api.models.TokenRefreshRequest
import ai.ciris.api.models.UserInfo

import ai.ciris.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class AuthenticationApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Configure Oauth Provider
     * Configure an OAuth provider.  Requires: users.write permission (SYSTEM_ADMIN only)
     * @param configureOAuthProviderRequest
     * @param authorization  (optional)
     * @return ConfigureOAuthProviderResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun configureOauthProviderV1AuthOauthProvidersPost(configureOAuthProviderRequest: ConfigureOAuthProviderRequest, authorization: kotlin.String? = null): HttpResponse<ConfigureOAuthProviderResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = configureOAuthProviderRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/oauth/providers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Create Api Key
     * Create a new API key for the authenticated user.  Users can create API keys for their OAuth identity with configurable expiry (30min - 7 days). The key is only shown once and cannot be retrieved later.
     * @param apIKeyCreateRequest
     * @param authorization  (optional)
     * @return APIKeyResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createApiKeyV1AuthApiKeysPost(apIKeyCreateRequest: APIKeyCreateRequest, authorization: kotlin.String? = null): HttpResponse<APIKeyResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = apIKeyCreateRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/api-keys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Delete Api Key
     * Delete an API key.  Users can only delete their own API keys.
     * @param keyId
     * @param authorization  (optional)
     * @return void
     */
    open suspend fun deleteApiKeyV1AuthApiKeysKeyIdDelete(keyId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/auth/api-keys/{key_id}".replace("{" + "key_id" + "}", "$keyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Current User
     * Get current authenticated user information.  Returns details about the currently authenticated user including their role and all permissions based on that role.
     * @param authorization  (optional)
     * @return UserInfo
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getCurrentUserV1AuthMeGet(authorization: kotlin.String? = null): HttpResponse<UserInfo> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/auth/me",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Api Keys
     * List all API keys for the authenticated user.  Returns information about all API keys created by the user (excluding the actual key values).
     * @param authorization  (optional)
     * @return APIKeyListResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listApiKeysV1AuthApiKeysGet(authorization: kotlin.String? = null): HttpResponse<APIKeyListResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/auth/api-keys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * List Oauth Providers
     * List configured OAuth providers.  Requires: users.write permission (SYSTEM_ADMIN only)
     * @param authorization  (optional)
     * @return OAuthProvidersResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listOauthProvidersV1AuthOauthProvidersGet(authorization: kotlin.String? = null): HttpResponse<OAuthProvidersResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/auth/oauth/providers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Login
     * Authenticate with username/password.  Currently supports system admin user only. In production, this would integrate with a proper user database.
     * @param loginRequest
     * @return LoginResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun loginV1AuthLoginPost(loginRequest: LoginRequest): HttpResponse<LoginResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = loginRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/login",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Logout
     * End the current session by revoking the API key.  This endpoint invalidates the current authentication token, effectively logging out the user.
     * @param authorization  (optional)
     * @return void
     */
    open suspend fun logoutV1AuthLogoutPost(authorization: kotlin.String? = null): HttpResponse<Unit> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/logout",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Native Google Token Exchange
     * Exchange a native Google ID token for a CIRIS API token.  This endpoint is used by native Android/iOS apps that perform Google Sign-In directly and need to exchange their Google ID token for a CIRIS API token.  Unlike the web OAuth flow (which uses authorization codes), native apps get ID tokens directly from Google Sign-In SDK and send them here.
     * @param nativeTokenRequest
     * @return NativeTokenResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun nativeGoogleTokenExchangeV1AuthNativeGooglePost(nativeTokenRequest: NativeTokenRequest): HttpResponse<NativeTokenResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = nativeTokenRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/native/google",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Oauth Callback
     * Handle OAuth callback.  Exchanges authorization code for tokens and creates/updates user. Extracts marketing_opt_in from redirect_uri if present.
     * @param provider
     * @param code
     * @param state
     * @param marketingOptIn  (optional, default to false)
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun oauthCallbackV1AuthOauthProviderCallbackGet(provider: kotlin.String, code: kotlin.String, state: kotlin.String, marketingOptIn: kotlin.Boolean? = false): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        code?.apply { localVariableQuery["code"] = listOf("$code") }
        state?.apply { localVariableQuery["state"] = listOf("$state") }
        marketingOptIn?.apply { localVariableQuery["marketing_opt_in"] = listOf("$marketingOptIn") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/auth/oauth/{provider}/callback".replace("{" + "provider" + "}", "$provider"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Oauth Login
     * Initiate OAuth login flow.  Redirects to the OAuth provider&#39;s authorization URL. Accepts optional redirect_uri to specify where to send tokens after OAuth.
     * @param provider
     * @param redirectUri  (optional)
     * @return kotlin.Any
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun oauthLoginV1AuthOauthProviderLoginGet(provider: kotlin.String, redirectUri: kotlin.String? = null): HttpResponse<kotlin.Any> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        redirectUri?.apply { localVariableQuery["redirect_uri"] = listOf("$redirectUri") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/auth/oauth/{provider}/login".replace("{" + "provider" + "}", "$provider"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Refresh Token
     * Refresh access token.  Creates a new access token and revokes the old one. Supports both API key and OAuth refresh flows. The user must be authenticated to refresh their token.
     * @param tokenRefreshRequest
     * @param authorization  (optional)
     * @return LoginResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun refreshTokenV1AuthRefreshPost(tokenRefreshRequest: TokenRefreshRequest, authorization: kotlin.String? = null): HttpResponse<LoginResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = tokenRefreshRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/auth/refresh",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
