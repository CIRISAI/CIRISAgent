/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package ai.ciris.api.apis

import ai.ciris.api.models.APIKeyInfo
import ai.ciris.api.models.APIRole
import ai.ciris.api.models.ChangePasswordRequest
import ai.ciris.api.models.CreateUserRequest
import ai.ciris.api.models.DeactivateUserResponse
import ai.ciris.api.models.HTTPValidationError
import ai.ciris.api.models.LinkOAuthAccountRequest
import ai.ciris.api.models.MintWARequest
import ai.ciris.api.models.PaginatedResponseUserSummary
import ai.ciris.api.models.PermissionRequestResponse
import ai.ciris.api.models.PermissionRequestUser
import ai.ciris.api.models.UpdatePermissionsRequest
import ai.ciris.api.models.UpdateUserRequest
import ai.ciris.api.models.UpdateUserSettingsRequest
import ai.ciris.api.models.UserDetail
import ai.ciris.api.models.UserSettingsResponse
import ai.ciris.api.models.WAKeyCheckResponse
import ai.ciris.api.models.WARole

import ai.ciris.api.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class UsersApi : ApiClient {

    constructor(
        baseUrl: String = ApiClient.BASE_URL,
        httpClientEngine: HttpClientEngine? = null,
        httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
        jsonSerializer: Json = ApiClient.JSON_DEFAULT
    ) : super(baseUrl = baseUrl, httpClientEngine = httpClientEngine, httpClientConfig = httpClientConfig, jsonBlock = jsonSerializer)

    constructor(
        baseUrl: String,
        httpClient: HttpClient
    ): super(baseUrl = baseUrl, httpClient = httpClient)

    /**
     * Change Password
     * Change user password.  Users can change their own password. SYSTEM_ADMIN can change any password without knowing current.
     * @param userId
     * @param changePasswordRequest
     * @param authorization  (optional)
     * @return kotlin.collections.Map<kotlin.String, kotlin.String>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun changePasswordV1UsersUserIdPasswordPut(userId: kotlin.String, changePasswordRequest: ChangePasswordRequest, authorization: kotlin.String? = null): HttpResponse<kotlin.collections.Map<kotlin.String, kotlin.String>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = changePasswordRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/{user_id}/password".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ChangePasswordV1UsersUserIdPasswordPutResponse>().map { value }
    }


    @Serializable(ChangePasswordV1UsersUserIdPasswordPutResponse.Companion::class)
    private class ChangePasswordV1UsersUserIdPasswordPutResponse(val value: Map<kotlin.String, kotlin.String>) {
        companion object : KSerializer<ChangePasswordV1UsersUserIdPasswordPutResponse> {
            private val serializer: KSerializer<Map<kotlin.String, kotlin.String>> = serializer<Map<String, kotlin.String>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: ChangePasswordV1UsersUserIdPasswordPutResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = ChangePasswordV1UsersUserIdPasswordPutResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Check Wa Key Exists
     * Check if a WA private key exists at the given filename.  Requires: wa.mint permission (SYSTEM_ADMIN only)  This is used by the UI to determine if auto-signing is available. Only checks files within ~/.ciris/wa_keys/ for security.
     * @param path Filename of private key to check
     * @param authorization  (optional)
     * @return WAKeyCheckResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun checkWaKeyExistsV1UsersWaKeyCheckGet(path: kotlin.String, authorization: kotlin.String? = null): HttpResponse<WAKeyCheckResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        path?.apply { localVariableQuery["path"] = listOf("$path") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/wa/key-check",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Create User
     * Create a new user account.  Requires: users.write permission (SYSTEM_ADMIN only)
     * @param createUserRequest
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createUserV1UsersPost(createUserRequest: CreateUserRequest, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = createUserRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Deactivate User
     * Deactivate a user account.  Requires: users.delete permission (SYSTEM_ADMIN only)
     * @param userId
     * @param authorization  (optional)
     * @return DeactivateUserResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun deactivateUserV1UsersUserIdDelete(userId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<DeactivateUserResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/users/{user_id}".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get My Settings
     * Get the current user&#39;s personal settings.  Requires: Must be authenticated (any role)
     * @param authorization  (optional)
     * @return UserSettingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getMySettingsV1UsersMeSettingsGet(authorization: kotlin.String? = null): HttpResponse<UserSettingsResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/me/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Get Permission Requests
     * Get list of users who have requested permissions.  Requires: ADMIN role or higher
     * @param includeGranted Include users who already have permissions (optional, default to false)
     * @param authorization  (optional)
     * @return kotlin.collections.List<PermissionRequestUser>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getPermissionRequestsV1UsersPermissionRequestsGet(includeGranted: kotlin.Boolean? = false, authorization: kotlin.String? = null): HttpResponse<kotlin.collections.List<PermissionRequestUser>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        includeGranted?.apply { localVariableQuery["include_granted"] = listOf("$includeGranted") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/permission-requests",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<GetPermissionRequestsV1UsersPermissionRequestsGetResponse>().map { value }
    }

    @Serializable(GetPermissionRequestsV1UsersPermissionRequestsGetResponse.Companion::class)
    private class GetPermissionRequestsV1UsersPermissionRequestsGetResponse(val value: List<PermissionRequestUser>) {
        companion object : KSerializer<GetPermissionRequestsV1UsersPermissionRequestsGetResponse> {
            private val serializer: KSerializer<List<PermissionRequestUser>> = serializer<List<PermissionRequestUser>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: GetPermissionRequestsV1UsersPermissionRequestsGetResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = GetPermissionRequestsV1UsersPermissionRequestsGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Get User
     * Get detailed information about a specific user.  Requires: users.read permission (ADMIN or higher)
     * @param userId
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getUserV1UsersUserIdGet(userId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/{user_id}".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Link Oauth Account
     * Link an OAuth identity to an existing user.  Users can link accounts to themselves without special permissions. Only SYSTEM_ADMIN can link accounts to other users.
     * @param userId
     * @param linkOAuthAccountRequest
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun linkOauthAccountV1UsersUserIdOauthLinksPost(userId: kotlin.String, linkOAuthAccountRequest: LinkOAuthAccountRequest, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = linkOAuthAccountRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/{user_id}/oauth-links".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * List User Api Keys
     * List API keys for a user.  Users can view their own keys. ADMIN+ can view any user&#39;s keys.
     * @param userId
     * @param authorization  (optional)
     * @return kotlin.collections.List<APIKeyInfo>
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listUserApiKeysV1UsersUserIdApiKeysGet(userId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<kotlin.collections.List<APIKeyInfo>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users/{user_id}/api-keys".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap<ListUserApiKeysV1UsersUserIdApiKeysGetResponse>().map { value }
    }

    @Serializable(ListUserApiKeysV1UsersUserIdApiKeysGetResponse.Companion::class)
    private class ListUserApiKeysV1UsersUserIdApiKeysGetResponse(val value: List<APIKeyInfo>) {
        companion object : KSerializer<ListUserApiKeysV1UsersUserIdApiKeysGetResponse> {
            private val serializer: KSerializer<List<APIKeyInfo>> = serializer<List<APIKeyInfo>>()
            override val descriptor = serializer.descriptor
            override fun serialize(encoder: Encoder, value: ListUserApiKeysV1UsersUserIdApiKeysGetResponse) = serializer.serialize(encoder, value.value)
            override fun deserialize(decoder: Decoder) = ListUserApiKeysV1UsersUserIdApiKeysGetResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * List Users
     * List all users with optional filtering.  Requires: users.read permission (ADMIN or higher)
     * @param page  (optional, default to 1)
     * @param pageSize  (optional, default to 20)
     * @param search  (optional)
     * @param authType  (optional)
     * @param apiRole  (optional)
     * @param waRole  (optional)
     * @param isActive  (optional)
     * @param authorization  (optional)
     * @return PaginatedResponseUserSummary
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun listUsersV1UsersGet(page: kotlin.Int? = 1, pageSize: kotlin.Int? = 20, search: kotlin.String? = null, authType: kotlin.String? = null, apiRole: APIRole? = null, waRole: WARole? = null, isActive: kotlin.Boolean? = null, authorization: kotlin.String? = null): HttpResponse<PaginatedResponseUserSummary> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        page?.apply { localVariableQuery["page"] = listOf("$page") }
        pageSize?.apply { localVariableQuery["page_size"] = listOf("$pageSize") }
        search?.apply { localVariableQuery["search"] = listOf("$search") }
        authType?.apply { localVariableQuery["auth_type"] = listOf("$authType") }
        apiRole?.apply { localVariableQuery["api_role"] = listOf("${ apiRole.value }") }
        waRole?.apply { localVariableQuery["wa_role"] = listOf("${ waRole.value }") }
        isActive?.apply { localVariableQuery["is_active"] = listOf("$isActive") }
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/users",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Mint Wise Authority
     * Mint a user as a Wise Authority.  Requires: ADMIN role or higher and valid Ed25519 signature from ROOT private key.  The signature should be over the message: \&quot;MINT_WA:{user_id}:{wa_role}:{timestamp}\&quot;  If no signature is provided and private_key_path is specified, will attempt to sign automatically using the key at that path.
     * @param userId
     * @param mintWARequest
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun mintWiseAuthorityV1UsersUserIdMintWaPost(userId: kotlin.String, mintWARequest: MintWARequest, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = mintWARequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/{user_id}/mint-wa".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Request Permissions
     * Request communication permissions for the current user.  Requires: Must be authenticated (any role)
     * @param authorization  (optional)
     * @return PermissionRequestResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun requestPermissionsV1UsersRequestPermissionsPost(authorization: kotlin.String? = null): HttpResponse<PermissionRequestResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/v1/users/request-permissions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Unlink Oauth Account
     * Remove a linked OAuth identity from a user.  Users can unlink accounts from themselves without special permissions. Only SYSTEM_ADMIN can unlink accounts from other users.
     * @param userId
     * @param provider
     * @param externalId
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun unlinkOauthAccountV1UsersUserIdOauthLinksProviderExternalIdDelete(userId: kotlin.String, provider: kotlin.String, externalId: kotlin.String, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.DELETE,
            "/v1/users/{user_id}/oauth-links/{provider}/{external_id}".replace("{" + "user_id" + "}", "$userId").replace("{" + "provider" + "}", "$provider").replace("{" + "external_id" + "}", "$externalId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }


    /**
     * Update My Settings
     * Update the current user&#39;s personal settings.  Requires: Must be authenticated (any role)  Note: This endpoint bypasses the MANAGED_USER_ATTRIBUTES protection because users are allowed to modify their own settings.
     * @param updateUserSettingsRequest
     * @param authorization  (optional)
     * @return UserSettingsResponse
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateMySettingsV1UsersMeSettingsPut(updateUserSettingsRequest: UpdateUserSettingsRequest, authorization: kotlin.String? = null): HttpResponse<UserSettingsResponse> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = updateUserSettingsRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/me/settings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update User Permissions
     * Update user&#39;s custom permissions.  Requires: users.permissions permission (AUTHORITY or higher)  This allows granting specific permissions to users beyond their role defaults. For example, granting SEND_MESSAGES permission to an OBSERVER.
     * @param userId
     * @param updatePermissionsRequest
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateUserPermissionsV1UsersUserIdPermissionsPut(userId: kotlin.String, updatePermissionsRequest: UpdatePermissionsRequest, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = updatePermissionsRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/{user_id}/permissions".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



    /**
     * Update User
     * Update user information (role, active status).  Requires: users.write permission (SYSTEM_ADMIN only)
     * @param userId
     * @param updateUserRequest
     * @param authorization  (optional)
     * @return UserDetail
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun updateUserV1UsersUserIdPut(userId: kotlin.String, updateUserRequest: UpdateUserRequest, authorization: kotlin.String? = null): HttpResponse<UserDetail> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = updateUserRequest

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()
        authorization?.apply { localVariableHeaders["authorization"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/v1/users/{user_id}".replace("{" + "user_id" + "}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
        ).wrap()
    }



}
